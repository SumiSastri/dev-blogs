__Why data structures__

- Access, store and process the data
- Formal definition and abstract definition
- Money charged for transaction of data - processing and transport

__What is a data structure__

- Difference between structured data and data structures

Search is an algorithm
Manage data
Solve problems
ICT (information-communication-tech)

- Protection, movement, storage of data
- LLM - large language model
- following instructions vs decision making (critical thinking)

- a way to organise a collection of data that is related in some way (to store, access and process)
- language dependent, new structures can not be created by developers
- with OOP possible - as classes will allow new data structures but maybe not data types
- virtually all data structures have underlying mathematical structures
- in processing data there is an "operational" view of the data
- storing data in memory has an "internal representation" of this data

__Types of data structures__

- Linear (sequential)
- Non-linear (non-sequential)
- Static (fixed size, sequential)
- Dynamic (no fixed size - data can be added or removed)
- Indexed (key-value pairs)
- Linked (non-indexed)

__Data and memory management__

Static data - fixed and small, can waste memory space, leave gaps and fragmentation of space
Dynamic - unknown variable data needs to be dealt with in compile time, data can shrink or grow in runtime

The 'new' key word allocates memory for new objects/ classes with a stack pointer referring to its address in the memory location

__Abstract Data Type - ADT__

- defined by data hiding or encapsulation
- interfaces and public methods access the data
- ADTs allow flexible manipulation of underlying data without modification to structure of the data
- ADTs change implementation not structure

__Algorithms__

A set of instructions performed in a sequence to secure a result
Efficiency based on
Time
Space

Analysis depends on
resources (size, complexity) and relative costs (efficiency, running time, storage required)

Types

- Brute force (slow)
- Divide and conquer (break up and solve in steps)
- Greedy (optimisation issues, dont always lead to a solution)

Alogrithms - training the computer to think
Claudia?

__Order of complexity of data__

- Efficiency or the order of complexity is often denoted as `n` or the amount/ size of data
- With graphs the vertices - or nodes more important/ the number of edges

Time is denoted with `t` or the length of time the program needs to run for

t(n) - is time and size of data
Big O
Upper bound - highest t(n) value or growth rate - worst case (steeper the gradient the worse the case)

Big Theta
Average bound - average case

Big Omega
Lower bound - is best case

LIFO-FIFO are alogrithms - how you manipulate data 
Queue FIFO

- Divide and conquer (break up and solve in steps)
Divide and conquer is a tree - top of the tree
Segment the tree

Tutorial: