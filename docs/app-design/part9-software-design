__The software cycle__

Requirements
Design
Implementation
Testing
Maintenance

__High level blue sky thinking__

- Identifies software as a system and how components interact with each other
- Required for assessing how to build before build starts
- What are you building and where
- What are system constraints
- What are tools available
- How will memory be managed
- How efficient will the system be - in memory allocation/ security
- Where will the system run?
- Performance 8-16 bit systems
- O/S
- Backwards compatibility?

__Architectural design__

Takes the high level thinking and puts a skeleton on it to work on
Concretises the ideas
Larger the system more scope for errors

__Modular structure of design__

- Breaks down the architectural design into what are the modules to be built and how
- Allocates the product lifecycle and how the software will be released and shipped
- Code encapsulation
- Looking at scalability of the modular design
- How do the units connect together
- What data is going to be communicated
- Containing - the information to one class - single responsibility

__Detailed design__

- Workflow level
- Who is building the system, what they require
- Unit level methods
- Testing
- Integration
- Building a working model
- Assembly/ integration/ testing
- Dry run testing

Work on that system module by module
Define the pre-post stages - maintenance

Single responsibility of a class makes the units more efficient in memory management
Create templates - on formats
Create object templates - form of values correct
Return the object that it is working and communicating how you expect
Target the error very quickly
Create a prototype for each component
Errors can feed into the system which becomes difficult to track and fix the error

__Levels of testing__
Requirements testing / user testing
Unit
Integration
System
Acceptance criteria for tests - what will make a test pass or fail
Alpha and beta testing

Start bottom upwards
Test as you go along
Testing tables
Try and break the method
Find its limitations
Simulations of testing

Errors if small can be patched but ideally dont ship with bugs
Requirements analysis - tickbox them again

Assess performance/ scalability

Test plan
Core testing results
Links to the tests
Prove and show evidence your test is working

Test scenarios - what fails needs to be flagged and identified

Point out the limitations of the system
Critically evaluate what is working and what is not working
The limitations of your system
Realistic about elements that work and do not work

Reviewing papers from industry may have errors - you need to highlight you know what you know and know you do not know

The V level model
The spiral model
